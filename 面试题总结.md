# 面试题总结

## 1. js事件冒泡、事件捕获和事件委托

https://www.jianshu.com/p/d3e9b653fa95
https://www.jb51.net/article/121063.htm

## 2. 跨域问题

## 3. 防抖节流

参考：[防抖节流](https://segmentfault.com/a/1190000018428170)

试想一个场景：在一个文章列表下拉过程中，当滑动到一定位置，右下角会出现一个按钮，用来返回顶部（毕竟，如果我们手动返回顶部太慢了！），这个按钮只有在页面滑动到一定位置才出现。所以我们就需要写这么一个监听浏览器滚动事件，返回当前滑动条与顶部距离的函数：

```js
function showBTop(){
    let scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    console.log("滚动条位置： " + scrollTop)
}
window.onscroll = showBTop;
```

但是当你滑动的时候，window.onscroll会调用数次（滑动一下调10次左右）showTop函数，这会严重损耗浏览器性能。

基于以上场景，我们需要做一个**防抖**操作：第一次调用会设置一个定时器，随后由于事件触发的调用都会使得定时器清空，直到操作结束后一定时间，才调用函数。

```js
function debounce(fn, delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer);
        }
        timer = setTimeout(fn, delay);
    }
}
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = debounce(showTop, 1000)
```

上面实现的效果使得：滑动操作调用debounce函数，第一次设置一个定时器，随后一直取消当前计时，并且重新计时，直到停止操作1s后，定时器时间结束，调用回调函数。

<font color='red'>防抖</font>：对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。

上面的操作还是有一个问题，如果用户一直滑动，不停下来，就会导致回调函数一直执行不了，从而使得按钮没法出现，所以我们需要**节流**操作：它类似于冷却时间，在持续滑动过程中，函数执行一次后，该函数在指定的期间内不再执行。

```js
function throttle(fn, delay){
    let valid = true;
    return function() {
        if(!valid){
            return false;
        }
        // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false;
        setTimeout(() => {
            fn()
            valid = true;
        }, delay);
    }
}

function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = throttle(showTop, 1000);
```

其他应用场景：

1. 搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。
2. 页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）。

## 4. CSS元素居中问题

需要区分行内元素、块元素、行内块元素

- 行内元素：a、span、string、em、br
- 块元素：html、body、div、p、ul（ol）、li、h1~h6、hr、form
- 行内块元素：img、input、button、textarea

行内元素不换行，不可设置宽高；块元素换行、可设置宽高；行内块元素不换行、可设置宽高。

1. 水平居中

    - 行内元素、行内块元素

    ```css
    /* 只需要行内元素的父元素是块元素，在块元素中设置如下属性 */
    .box {
        text-align: center;
    }
    ```

    <font color='red'>通常可以用来设置按钮(行内块元素)居中</font>

    - 块元素

    ```css
    /* 块元素上设置宽度+外边距自适应 */
    .box {
        width: 100px;
        margin: 0 auto;
    }
    ```

2. 垂直居中

    - 行内元素、行内块元素

    ```css
    /* 父元素为块级元素，并设置高
    元素设置行高等于父元素高*/
    .box {
        height: 100px;
    }

    .box a {
        line-height: 100px;
    }
    ```

    - 块元素

    ```css
    /* 块元素上设置高度，利用绝对定位
    需要设置其父元素为相对定位 */
    .box {
        height: 200px;
        position: relative;
    }

    .box div {
        position: absolute;
        height: 20px;
        width: 20px;
        /*100px-20px/2*/
        top: 90px;
    }
    ```

3. 水平垂直居中

- 行内元素、行内块元素

    ```css
    /*将水平和垂直结合*/
    .box {
        text-align: center;
        line-height: 100px;
    }
    .box a {
        height: 100px;
    }
    ```

    ```css
    /* 将父元素转化为表格布局元素
    设置垂直方向居中*/
    .box {
        height: 100px;
        display: table-cell;
        vertical-align: middle;
        text-align: center;
    }
    ```

- 所有元素都可以（利用定位）
    <font color='red'>方法1：使用的前提是必须要设置元素宽高</font>

    ```css
    /* 父元素必须是相对定位
    在元素上设置绝对定位，元素可以是任意类型，但是必须设置宽和高*/
    .box {
        position: absolute;
        width: 10px;
        height: 10px;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
    }
    ```

    ```css
    /* 更为灵活的做法
    定位顶和左，由于设置50%，需要减去盒子宽高的一半*/
    .box {
        position: absolute;
        width: 10px;
        height: 20px;
        top: 50%;
        left: 50%;
        margin-top: -10px;  
        margin-left: -5px;
    }
    ```

    <font color='red'>方法2：不设置宽高</font>

    ```css
    /* 利用translate平移百分比设置依据自身宽高*/
    .box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    ```

- 使用flex（推荐）

    ```css
    /* 父元素设置*/
    .parentBox {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    ```
